header "post_include_hpp" {
    // gets inserted after antlr generated includes in the header file
     // outside any generated namespace specifications
#include "antlr/RecognitionException.hpp"
#include "grammar/Re2cLexer.hpp"
#include <assert.h>

}

options{
    language="Cpp";
}

// Using external Re2cLexer now
class SmaliParser extends Parser;
options{
    importVocab=Re2c;
}

{
    private:
        Re2cLexer * lexer_ = nullptr;

    public:
        void setMode( LexerMode mode ){
            assert( lexer_ != nullptr );
            lexer_->setMode( mode );
        }

        SmaliParser( antlr::TokenStream& token_stream , Re2cLexer * lexer ) : SmaliParser( token_stream ){
            lexer_ = lexer;
        }
        
    /** Parser error-reporting function can be overridden in subclass */
    void reportError(const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
    {
        ANTLR_USE_NAMESPACE(std)cerr << ex.toString().c_str() << ANTLR_USE_NAMESPACE(std)endl;
        throw ex;
    }

    /** Parser error-reporting function can be overridden in subclass */
    void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
    {
        if ( getFilename()=="" )
            ANTLR_USE_NAMESPACE(std)cerr << "error: " << s.c_str() << ANTLR_USE_NAMESPACE(std)endl;
        else
            ANTLR_USE_NAMESPACE(std)cerr << getFilename().c_str() << ": error: " << s.c_str() << ANTLR_USE_NAMESPACE(std)endl;
        throw new antlr::RecognitionException(s);
    }

    /** Parser warning-reporting function can be overridden in subclass */
    void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
    {
        if ( getFilename()=="" )
            ANTLR_USE_NAMESPACE(std)cerr << "warning: " << s.c_str() << ANTLR_USE_NAMESPACE(std)endl;
        else
            ANTLR_USE_NAMESPACE(std)cerr << getFilename().c_str() << ": warning: " << s.c_str() << ANTLR_USE_NAMESPACE(std)endl;
        throw new antlr::RecognitionException(s);
    }
}

classDecl : DIR_CLASS visualDecl CLASSNAME;
superDecl : DIR_SUPER CLASSNAME;
sourceDecl : DIR_SOURCE STRING;
fieldDecl : DIR_FIELD visualDecl fieldName;
annotationDecl : annotationHeader annotationValue annotationEnd;
methodDecl : DIR_METHOD visualDecl methodName parameterTypeIds returnTypeId;

protected
fieldName { setMode( LexerMode::fieldName ); } : FIELDNAME;
methodName : ID;
returnTypeId { setMode( LexerMode::returnTypeId ); } : RETURN_TYPE_ID;
parameterTypeIds : LEFT_PAREN { setMode( LexerMode::parameterTypeIds ); } (TYPE_ID)* RIGHT_PAREN;



visualDecl : PUBLIC  | PRIVATE;
annotationHeader : DIR_ANNOTATION ID CLASSNAME;
annotationValue : ID ASSIGN LEFT_BRACE (CLASSNAME)* RIGHT_BRACE;
annotationEnd : END_ANNOTATION;

//following rule surrond by auto-gen comment is auto generated by gendalvik.rb, please don't edit them even if comments
//start auto-gen instruction
//end auto-gen instruction

