#include <assert.h>
#include <cstring>
#include <exception>
#include <memory>
#include "grammar/Re2cLexer.hpp"
#include "grammar/Re2cTokenType.hpp"
#include "antlr/CommonToken.hpp"

#define reportError() reportError( __FILE__, __LINE__, std::string(getLiteralFirst(), cursor + 1), cursor )
#define	YYCTYPE		    char
#define YYCURSOR        cursor
#define	YYMARKER		yymark
#define YYLIMIT         yylimit
#define YYFILL(n) {\
    int offset = fillData( n, cursor, yylimit, yymark ); \
    if( offset > 0 ){ \
    } \
}

#define RETURN(token_type) {\
    std::unique_ptr<antlr::CommonToken> token_ptr(new antlr::CommonToken(token_type, std::string(getLiteralFirst(), cursor)));\
    finishMatch(cursor); \
    std::cerr << "Return token:" << token_type << std::endl; \
    return antlr::RefToken(token_ptr.release());\
}
    

antlr::RefToken Re2cLexer::nextToken()
{
    char ch;
    char *cursor;
    char *yymark;
    char *yylimit;

    loadBuf( cursor, yylimit );

    for(;;) {
       startNewMatch(cursor);

       switch(mode_){
           case LexerMode::fieldName:
               /*!re2c
                re2c:indent:top = 1;
                re2c:indent:string = "    ";

                ANY = [\000-\377];
                SPACE = [ \t];
                DIGIT = [0-9];
                ALPHA = [a-zA-Z];
                ID = ( "_" | ALPHA)( "_"|ALPHA|DIGIT|"$")*;
                SEMICOLON = ";";
                COLON = ":";
                SLASH = "/";
                CLASSNAME = "L" ID ( SLASH ID )* SEMICOLON;
                TYPE_ID = ( "Z" | "B" | "S" | "C" | "I" | "J" | "F" | "D" | CLASSNAME );
                RETURN_TYPE_ID = ( "V" | TYPE_ID );

                ID ":" TYPE_ID  
                    { 
                        mode_ = LexerMode::None; 
                        RETURN(FIELDNAME); 
                    }
                * { reportError(); }

               */
             break;

           case LexerMode::parameterTypeIds:
                /*!re2c
                re2c:indent:top = 1;
                re2c:indent:string = "    ";

                TYPE_ID 
                    {
                        RETURN(TYPE_ID);
                    }

                ")" 
                    {
                        mode_ = LexerMode::None;
                        RETURN(RIGHT_PAREN);
                    }

                * { reportError(); }
                */
                break;

           case LexerMode::returnTypeId:
                /*!re2c
                re2c:indent:top = 1;
                re2c:indent:string = "    ";

                RETURN_TYPE_ID 
                    {
                        RETURN(RETURN_TYPE_ID);
                    }

                * { reportError(); }
                */
                break;

           case LexerMode::None:
                /*!re2c
              re2c:indent:top = 1;
              re2c:indent:string = "    ";

              ".method"   
                    { RETURN(DIR_METHOD); }
              ".end" SPACE+ "method" 
                    { RETURN(END_METHOD); }
              ".class" { RETURN(DIR_CLASS); }
              ".local" { RETURN(DIR_LOCAL); }
              ".locals" { RETURN(DIR_LOCALS); }
              ".source" { RETURN(DIR_SOURCE); }
              ".field" { RETURN(DIR_FIELD); }
              ".annotation" { RETURN(DIR_ANNOTATION); }
              ".end"  SPACE+ "annotation" { RETURN(END_ANNOTATION); }
              ".super" { RETURN(DIR_SUPER); }
               "public" { RETURN(PUBLIC); }
               "private" { RETURN(PRIVATE);}
               "constructor" { RETURN(CONSTRUCTOR); }

               //following rule surrond by auto-gen comment is auto generated by gendalvik.rb, please don't edit them even if comments
               //start auto-gen instruction
               //end auto-gen instruction

              "L" ID ( SLASH ID )* SEMICOLON { RETURN(CLASSNAME); }
               ID { RETURN(ID); }

               "(" { RETURN(LEFT_PAREN); }
               ")" { RETURN(RIGHT_PAREN); }
               "{" { RETURN(LEFT_BRACE); }
               "}" { RETURN(RIGHT_BRACE); }
               "=" { RETURN(ASSIGN); }
               SLASH { RETURN(SLASH);}
               SEMICOLON { RETURN(SEMICOLON); }
               COLON { RETURN(COLON); }

               "\"" [^"]* "\"" { RETURN(STRING); }

               


              "\n"        
                  { 
                      if( eof(cursor) ){
                          //TODO should handle it. is 0 a good one???
                        RETURN(-1);
                      }
                      nextline(cursor); 
                      continue;
                  }

              SPACE+ 
                  {
                      continue;
                  }
                
              
               *
                  {
                        reportError();
                  }
                */
                break;
            }
        }
}
