#include <assert.h>
#include <cstring>
#include <exception>
#include <memory>
#include "grammar/Re2cLexer.hpp"
#include "grammar/Re2cTokenType.hpp"
#include "antlr/CommonToken.hpp"

#define reportError() reportError( __FILE__, __LINE__, std::string(literal_first, cursor + 1), cursor )
#define	YYCTYPE		    char
#define YYCURSOR        cursor
#define	YYMARKER		yymark
#define YYLIMIT         yylimit
#define YYFILL(n) {\
    if( fillData( literal_first - buf_, cursor - buf_, n ) ){ \
        int offset = literal_first - buf_; \
        literal_first = buf_; \
        cursor -= offset; \
        col_ptr_ -= offset; \
        yymark -= offset; \
        yylimit = buf_ + data_end_; \
    } \
}

#define RETURN(token_type) {\
    std::unique_ptr<antlr::CommonToken> token_ptr(new antlr::CommonToken(token_type, std::string(literal_first, cursor)));\
    data_start_ = cursor - buf_; \
    std::cerr << "Return token:" << token_type << std::endl; \
    return antlr::RefToken(token_ptr.release());\
}
    

antlr::RefToken Re2cLexer::nextToken()
{
    char ch;
    char *cursor = buf_ + data_start_;
    char *yymark;
    char *yylimit = buf_ + data_end_;

    for(;;) {
        char * literal_first = cursor;
        col_no_ += cursor - col_ptr_;
        col_ptr_ = cursor;

        switch( mode_ ){
            case Mode::None: {
                /*!re2c
              re2c:indent:top = 2;
              re2c:indent:string = "    ";

              ANY = [\000-\377];
              SPACE = [ \t];
              DIGIT = [0-9];
              ALPHA = [a-zA-Z];
              ID = ( ( "_" | ALPHA)( "_"|ALPHA|DIGIT|"$")* | "<init>" );
              SEMICOLON = ";";
              COLON = ":";
              SLASH = "/";
              HEX = [0-9A-Fa-f];
              

              ".method"   
                    { RETURN(DIR_METHOD); }
              ".end" SPACE+ "method" 
                    { RETURN(END_METHOD); }
              ".class" { RETURN(DIR_CLASS); }
              ".local" { RETURN(DIR_LOCAL); }
              ".locals" { RETURN(DIR_LOCALS); }
              ".source" { RETURN(DIR_SOURCE); }
              ".field" { RETURN(DIR_FIELD); }
              ".annotation" { RETURN(DIR_ANNOTATION); }
              ".end"  SPACE+ "annotation" { RETURN(END_ANNOTATION); }
              ".super" { RETURN(DIR_SUPER); }
               "public" { RETURN(PUBLIC); }
               "private" { RETURN(PRIVATE);}

               "#" HEX HEX HEX HEX { RETURN(LIT16); }
               "#" HEX HEX HEX { RETURN(LIT8); }

               //following rule surrond by auto-gen comment is auto generated by gendalvik.rb, please don't edit them even if comments
               //start auto-gen instruction
                "xor-long/2addr" { RETURN(INS_XOR_LONG_2ADDR); }
                "xor-long" { RETURN(INS_XOR_LONG); }
                "xor-int/lit8" { RETURN(INS_XOR_INT_LIT8); }
                "xor-int/lit16" { RETURN(INS_XOR_INT_LIT16); }
                "xor-int/2addr" { RETURN(INS_XOR_INT_2ADDR); }
                "xor-int" { RETURN(INS_XOR_INT); }
                "ushr-long/2addr" { RETURN(INS_USHR_LONG_2ADDR); }
                "ushr-long" { RETURN(INS_USHR_LONG); }
                "ushr-int/lit8" { RETURN(INS_USHR_INT_LIT8); }
                "ushr-int/2addr" { RETURN(INS_USHR_INT_2ADDR); }
                "ushr-int" { RETURN(INS_USHR_INT); }
                "throw" { RETURN(INS_THROW); }
                "sub-long/2addr" { RETURN(INS_SUB_LONG_2ADDR); }
                "sub-long" { RETURN(INS_SUB_LONG); }
                "sub-int/lit8" { RETURN(INS_SUB_INT_LIT8); }
                "sub-int/lit16" { RETURN(INS_SUB_INT_LIT16); }
                "sub-int/2addr" { RETURN(INS_SUB_INT_2ADDR); }
                "sub-int" { RETURN(INS_SUB_INT); }
                "sub-float/2addr" { RETURN(INS_SUB_FLOAT_2ADDR); }
                "sub-float" { RETURN(INS_SUB_FLOAT); }
                "sub-double/2addr" { RETURN(INS_SUB_DOUBLE_2ADDR); }
                "sub-double" { RETURN(INS_SUB_DOUBLE); }
                "sput-wide" { RETURN(INS_SPUT_WIDE); }
                "sput-short" { RETURN(INS_SPUT_SHORT); }
                "sput-object" { RETURN(INS_SPUT_OBJECT); }
                "sput-char" { RETURN(INS_SPUT_CHAR); }
                "sput-byte" { RETURN(INS_SPUT_BYTE); }
                "sput-boolean" { RETURN(INS_SPUT_BOOLEAN); }
                "sput" { RETURN(INS_SPUT); }
                "sparse-switch" { RETURN(INS_SPARSE_SWITCH); }
                "shr-long/2addr" { RETURN(INS_SHR_LONG_2ADDR); }
                "shr-long" { RETURN(INS_SHR_LONG); }
                "shr-int/lit8" { RETURN(INS_SHR_INT_LIT8); }
                "shr-int/2addr" { RETURN(INS_SHR_INT_2ADDR); }
                "shr-int" { RETURN(INS_SHR_INT); }
                "shl-long/2addr" { RETURN(INS_SHL_LONG_2ADDR); }
                "shl-long" { RETURN(INS_SHL_LONG); }
                "shl-int/lit8" { RETURN(INS_SHL_INT_LIT8); }
                "shl-int/2addr" { RETURN(INS_SHL_INT_2ADDR); }
                "shl-int" { RETURN(INS_SHL_INT); }
                "sget-wide" { RETURN(INS_SGET_WIDE); }
                "sget-short" { RETURN(INS_SGET_SHORT); }
                "sget-object" { RETURN(INS_SGET_OBJECT); }
                "sget-char" { RETURN(INS_SGET_CHAR); }
                "sget-byte" { RETURN(INS_SGET_BYTE); }
                "sget-boolean" { RETURN(INS_SGET_BOOLEAN); }
                "sget" { RETURN(INS_SGET); }
                "return-wide" { RETURN(INS_RETURN_WIDE); }
                "return-void" { RETURN(INS_RETURN_VOID); }
                "return-object" { RETURN(INS_RETURN_OBJECT); }
                "return" { RETURN(INS_RETURN); }
                "rem-long/2addr" { RETURN(INS_REM_LONG_2ADDR); }
                "rem-long" { RETURN(INS_REM_LONG); }
                "rem-int/lit8" { RETURN(INS_REM_INT_LIT8); }
                "rem-int/lit16" { RETURN(INS_REM_INT_LIT16); }
                "rem-int/2addr" { RETURN(INS_REM_INT_2ADDR); }
                "rem-int" { RETURN(INS_REM_INT); }
                "rem-float/2addr" { RETURN(INS_REM_FLOAT_2ADDR); }
                "rem-float" { RETURN(INS_REM_FLOAT); }
                "rem-double/2addr" { RETURN(INS_REM_DOUBLE_2ADDR); }
                "rem-double" { RETURN(INS_REM_DOUBLE); }
                "packed-switch" { RETURN(INS_PACKED_SWITCH); }
                "or-long/2addr" { RETURN(INS_OR_LONG_2ADDR); }
                "or-long" { RETURN(INS_OR_LONG); }
                "or-int/lit8" { RETURN(INS_OR_INT_LIT8); }
                "or-int/lit16" { RETURN(INS_OR_INT_LIT16); }
                "or-int/2addr" { RETURN(INS_OR_INT_2ADDR); }
                "or-int" { RETURN(INS_OR_INT); }
                "not-long" { RETURN(INS_NOT_LONG); }
                "not-int" { RETURN(INS_NOT_INT); }
                "nop" { RETURN(INS_NOP); }
                "new-instance" { RETURN(INS_NEW_INSTANCE); }
                "new-array" { RETURN(INS_NEW_ARRAY); }
                "neg-long" { RETURN(INS_NEG_LONG); }
                "neg-int" { RETURN(INS_NEG_INT); }
                "neg-float" { RETURN(INS_NEG_FLOAT); }
                "neg-double" { RETURN(INS_NEG_DOUBLE); }
                "mul-long/2addr" { RETURN(INS_MUL_LONG_2ADDR); }
                "mul-long" { RETURN(INS_MUL_LONG); }
                "mul-int/lit8" { RETURN(INS_MUL_INT_LIT8); }
                "mul-int/lit16" { RETURN(INS_MUL_INT_LIT16); }
                "mul-int/2addr" { RETURN(INS_MUL_INT_2ADDR); }
                "mul-int" { RETURN(INS_MUL_INT); }
                "mul-float/2addr" { RETURN(INS_MUL_FLOAT_2ADDR); }
                "mul-float" { RETURN(INS_MUL_FLOAT); }
                "mul-double/2addr" { RETURN(INS_MUL_DOUBLE_2ADDR); }
                "mul-double" { RETURN(INS_MUL_DOUBLE); }
                "move/from16" { RETURN(INS_MOVE_FROM16); }
                "move/16" { RETURN(INS_MOVE_16); }
                "move-wide/from16" { RETURN(INS_MOVE_WIDE_FROM16); }
                "move-wide/16" { RETURN(INS_MOVE_WIDE_16); }
                "move-wide" { RETURN(INS_MOVE_WIDE); }
                "move-result-wide" { RETURN(INS_MOVE_RESULT_WIDE); }
                "move-result-object" { RETURN(INS_MOVE_RESULT_OBJECT); }
                "move-result" { RETURN(INS_MOVE_RESULT); }
                "move-object/from16" { RETURN(INS_MOVE_OBJECT_FROM16); }
                "move-object/16" { RETURN(INS_MOVE_OBJECT_16); }
                "move-object" { RETURN(INS_MOVE_OBJECT); }
                "move-exception" { RETURN(INS_MOVE_EXCEPTION); }
                "move" { RETURN(INS_MOVE); }
                "monitor-exit" { RETURN(INS_MONITOR_EXIT); }
                "monitor-enter" { RETURN(INS_MONITOR_ENTER); }
                "long-to-int" { RETURN(INS_LONG_TO_INT); }
                "long-to-float" { RETURN(INS_LONG_TO_FLOAT); }
                "long-to-double" { RETURN(INS_LONG_TO_DOUBLE); }
                "iput-wide-quick" { RETURN(INS_IPUT_WIDE_QUICK); }
                "iput-wide" { RETURN(INS_IPUT_WIDE); }
                "iput-short" { RETURN(INS_IPUT_SHORT); }
                "iput-quick" { RETURN(INS_IPUT_QUICK); }
                "iput-object-quick" { RETURN(INS_IPUT_OBJECT_QUICK); }
                "iput-object" { RETURN(INS_IPUT_OBJECT); }
                "iput-char" { RETURN(INS_IPUT_CHAR); }
                "iput-byte" { RETURN(INS_IPUT_BYTE); }
                "iput-boolean" { RETURN(INS_IPUT_BOOLEAN); }
                "iput" { RETURN(INS_IPUT); }
                "invoke-virtual/range" { RETURN(INS_INVOKE_VIRTUAL_RANGE); }
                "invoke-virtual-quick/range" { RETURN(INS_INVOKE_VIRTUAL_QUICK_RANGE); }
                "invoke-virtual-quick" { RETURN(INS_INVOKE_VIRTUAL_QUICK); }
                "invoke-virtual" { RETURN(INS_INVOKE_VIRTUAL); }
                "invoke-super/range" { RETURN(INS_INVOKE_SUPER_RANGE); }
                "invoke-super-quick/range" { RETURN(INS_INVOKE_SUPER_QUICK_RANGE); }
                "invoke-super-quick" { RETURN(INS_INVOKE_SUPER_QUICK); }
                "invoke-super" { RETURN(INS_INVOKE_SUPER); }
                "invoke-static/range" { RETURN(INS_INVOKE_STATIC_RANGE); }
                "invoke-static" { RETURN(INS_INVOKE_STATIC); }
                "invoke-interface-range" { RETURN(INS_INVOKE_INTERFACE_RANGE); }
                "invoke-interface" { RETURN(INS_INVOKE_INTERFACE); }
                "invoke-direct/range" { RETURN(INS_INVOKE_DIRECT_RANGE); }
                "invoke-direct-empty" { RETURN(INS_INVOKE_DIRECT_EMPTY); }
                "invoke-direct" { RETURN(INS_INVOKE_DIRECT); }
                "int-to-short" { RETURN(INS_INT_TO_SHORT); }
                "int-to-long" { RETURN(INS_INT_TO_LONG); }
                "int-to-float" { RETURN(INS_INT_TO_FLOAT); }
                "int-to-double" { RETURN(INS_INT_TO_DOUBLE); }
                "int-to-char" { RETURN(INS_INT_TO_CHAR); }
                "int-to-byte" { RETURN(INS_INT_TO_BYTE); }
                "instance-of" { RETURN(INS_INSTANCE_OF); }
                "iget-wide-quick" { RETURN(INS_IGET_WIDE_QUICK); }
                "iget-wide" { RETURN(INS_IGET_WIDE); }
                "iget-short" { RETURN(INS_IGET_SHORT); }
                "iget-quick" { RETURN(INS_IGET_QUICK); }
                "iget-object-quick" { RETURN(INS_IGET_OBJECT_QUICK); }
                "iget-object" { RETURN(INS_IGET_OBJECT); }
                "iget-char" { RETURN(INS_IGET_CHAR); }
                "iget-byte" { RETURN(INS_IGET_BYTE); }
                "iget-boolean" { RETURN(INS_IGET_BOOLEAN); }
                "iget" { RETURN(INS_IGET); }
                "if-nez" { RETURN(INS_IF_NEZ); }
                "if-ne" { RETURN(INS_IF_NE); }
                "if-ltz" { RETURN(INS_IF_LTZ); }
                "if-lt" { RETURN(INS_IF_LT); }
                "if-lez" { RETURN(INS_IF_LEZ); }
                "if-le" { RETURN(INS_IF_LE); }
                "if-gtz" { RETURN(INS_IF_GTZ); }
                "if-gt" { RETURN(INS_IF_GT); }
                "if-gez" { RETURN(INS_IF_GEZ); }
                "if-ge" { RETURN(INS_IF_GE); }
                "if-eqz" { RETURN(INS_IF_EQZ); }
                "if-eq" { RETURN(INS_IF_EQ); }
                "goto/32" { RETURN(INS_GOTO_32); }
                "goto/16" { RETURN(INS_GOTO_16); }
                "goto" { RETURN(INS_GOTO); }
                "float-to-long" { RETURN(INS_FLOAT_TO_LONG); }
                "float-to-int" { RETURN(INS_FLOAT_TO_INT); }
                "float-to-double" { RETURN(INS_FLOAT_TO_DOUBLE); }
                "filled-new-array-range" { RETURN(INS_FILLED_NEW_ARRAY_RANGE); }
                "filled-new-array" { RETURN(INS_FILLED_NEW_ARRAY); }
                "fill-array-data" { RETURN(INS_FILL_ARRAY_DATA); }
                "execute-inline" { RETURN(INS_EXECUTE_INLINE); }
                "double-to-long" { RETURN(INS_DOUBLE_TO_LONG); }
                "double-to-int" { RETURN(INS_DOUBLE_TO_INT); }
                "double-to-float" { RETURN(INS_DOUBLE_TO_FLOAT); }
                "div-long/2addr" { RETURN(INS_DIV_LONG_2ADDR); }
                "div-long" { RETURN(INS_DIV_LONG); }
                "div-int/lit8" { RETURN(INS_DIV_INT_LIT8); }
                "div-int/lit16" { RETURN(INS_DIV_INT_LIT16); }
                "div-int/2addr" { RETURN(INS_DIV_INT_2ADDR); }
                "div-int" { RETURN(INS_DIV_INT); }
                "div-float/2addr" { RETURN(INS_DIV_FLOAT_2ADDR); }
                "div-float" { RETURN(INS_DIV_FLOAT); }
                "div-double/2addr" { RETURN(INS_DIV_DOUBLE_2ADDR); }
                "div-double" { RETURN(INS_DIV_DOUBLE); }
                "const/high16" { RETURN(INS_CONST_HIGH16); }
                "const/4" { RETURN(INS_CONST_4); }
                "const/16" { RETURN(INS_CONST_16); }
                "const-wide/high16" { RETURN(INS_CONST_WIDE_HIGH16); }
                "const-wide/32" { RETURN(INS_CONST_WIDE_32); }
                "const-wide/16" { RETURN(INS_CONST_WIDE_16); }
                "const-wide" { RETURN(INS_CONST_WIDE); }
                "const-string-jumbo" { RETURN(INS_CONST_STRING_JUMBO); }
                "const-string" { RETURN(INS_CONST_STRING); }
                "const-class" { RETURN(INS_CONST_CLASS); }
                "const" { RETURN(INS_CONST); }
                "cmpl-float" { RETURN(INS_CMPL_FLOAT); }
                "cmpl-double" { RETURN(INS_CMPL_DOUBLE); }
                "cmpg-float" { RETURN(INS_CMPG_FLOAT); }
                "cmpg-double" { RETURN(INS_CMPG_DOUBLE); }
                "cmp-long" { RETURN(INS_CMP_LONG); }
                "check-cast" { RETURN(INS_CHECK_CAST); }
                "array-length" { RETURN(INS_ARRAY_LENGTH); }
                "aput-wide" { RETURN(INS_APUT_WIDE); }
                "aput-short" { RETURN(INS_APUT_SHORT); }
                "aput-object" { RETURN(INS_APUT_OBJECT); }
                "aput-char" { RETURN(INS_APUT_CHAR); }
                "aput-byte" { RETURN(INS_APUT_BYTE); }
                "aput-boolean" { RETURN(INS_APUT_BOOLEAN); }
                "aput" { RETURN(INS_APUT); }
                "and-long/2addr" { RETURN(INS_AND_LONG_2ADDR); }
                "and-long" { RETURN(INS_AND_LONG); }
                "and-int/lit8" { RETURN(INS_AND_INT_LIT8); }
                "and-int/lit16" { RETURN(INS_AND_INT_LIT16); }
                "and-int/2addr" { RETURN(INS_AND_INT_2ADDR); }
                "and-int" { RETURN(INS_AND_INT); }
                "aget-wide" { RETURN(INS_AGET_WIDE); }
                "aget-short" { RETURN(INS_AGET_SHORT); }
                "aget-object" { RETURN(INS_AGET_OBJECT); }
                "aget-char" { RETURN(INS_AGET_CHAR); }
                "aget-byte" { RETURN(INS_AGET_BYTE); }
                "aget-boolean" { RETURN(INS_AGET_BOOLEAN); }
                "aget" { RETURN(INS_AGET); }
                "add-long/2addr" { RETURN(INS_ADD_LONG_2ADDR); }
                "add-long" { RETURN(INS_ADD_LONG); }
                "add-int/lit8" { RETURN(INS_ADD_INT_LIT8); }
                "add-int/lit16" { RETURN(INS_ADD_INT_LIT16); }
                "add-int/2addr" { RETURN(INS_ADD_INT_2ADDR); }
                "add-int" { RETURN(INS_ADD_INT); }
                "add-float/2addr" { RETURN(INS_ADD_FLOAT_2ADDR); }
                "add-float" { RETURN(INS_ADD_FLOAT); }
                "add-double/2addr" { RETURN(INS_ADD_DOUBLE_2ADDR); }
                "add-double" { RETURN(INS_ADD_DOUBLE); }
               //end auto-gen instruction

              "L" ID ( SLASH ID )* SEMICOLON { RETURN(CLASSNAME); }

               ID { RETURN(ID); }

               "->" {RETURN(ARROW);}

               ".." { RETURN(DOTDOT); }
               "," { RETURN(COMMA); }

               "(" { RETURN(LEFT_PAREN); }
               ")" { RETURN(RIGHT_PAREN); }
               "{" { RETURN(LEFT_BRACE); }
               "}" { RETURN(RIGHT_BRACE); }
               "=" { RETURN(ASSIGN); }
               SLASH { RETURN(SLASH);}
               SEMICOLON { RETURN(SEMICOLON); }
               COLON { RETURN(COLON); }

               "\"" [^"]* "\"" { RETURN(STRING); }

               "\n"        
                  { 
                      if( eof(cursor) ){
                          //TODO should handle it. is 0 a good one???
                        RETURN(-1);
                      }
                      nextline(cursor); 
                      continue;
                  }

              SPACE+ 
                  {
                      continue;
                  }
                
              
               *
                  {
                        reportError();
                  }
            */
            }
                break;

                case Mode::Register:
                /*!re2c
                  [v|p][0..9]+ 
                    { 
                          clearMode(); 
                          RETURN(REGISTER); 
                    }
                */
                break;

                case Mode::TypeId:
                /*!re2c
                  
               */
                break;
            }
        }
}

void Re2cLexer::readData(int offset, int need_chars){
        std::cerr << "readData:" << offset << "," << need_chars << std::endl;
    assert( offset >= 0 );
    assert( offset < buf_len_ );
    assert( offset == data_end_ ); 
    assert( offset + need_chars <= buf_len_ );

    input_stream_.read( buf_+offset, buf_len_ - offset );
    data_end_ += input_stream_.gcount();

    if( input_stream_.gcount() < need_chars ){
        if( input_stream_.eof() ){
            is_stream_eof_ = true;
            end_pos_ = buf_ + data_end_;
            for(int i = input_stream_.gcount(); i < need_chars; ++i){
                std::cerr << "fillData: append fake endline:" <<  need_chars << std::endl;
                buf_[data_end_ + i] = '\n';
            }
            data_end_ += need_chars - input_stream_.gcount();

        }else{
            std::cerr << "Stream error in readData";
            throw std::runtime_error("Stream error!");
        }
    }

    assert( data_end_ <= buf_len_ );
    assert( data_end_ > 0 );
    assert( data_end_ - offset >= need_chars );

}

bool Re2cLexer::eof(char * cursor){
    if( is_stream_eof_ ){
        if( cursor >= end_pos_ ){
            return true;
        }
    }
    return false;
}

bool Re2cLexer::fillData(int first_char_index_should_keep, int index_to_put_new_data, int need_chars ){
    bool retval = false;

    std::cerr << "fillData:" << first_char_index_should_keep << "," << index_to_put_new_data << "," << need_chars << std::endl;

    assert( index_to_put_new_data <= data_end_ );
    //index_to_put_new_data may not reach data_end_

    if( ( index_to_put_new_data + need_chars ) <= data_end_ ){
        //already meet requirement, should happend
        assert(false);
    }

    //adjust if data_end_ != index_to_put_new_data
    need_chars -= data_end_ - index_to_put_new_data;
    assert( need_chars > 0 );
    index_to_put_new_data = data_end_;

    if( need_chars > (buf_len_ - data_end_ ) ){
        retval = true;

        //check if we can full fill need_chars after move
        if( need_chars > (buf_len_ - ( data_end_ - first_char_index_should_keep ))){
            assert(false); //FIXME should handle this
        }

        std::cerr << "moveData:" << data_end_ - first_char_index_should_keep << std::endl;
        std::memmove( buf_, buf_+first_char_index_should_keep, data_end_ - first_char_index_should_keep );
                
        data_end_ = data_end_ - first_char_index_should_keep;
    }

    readData(data_end_,need_chars);

    return retval;
}
